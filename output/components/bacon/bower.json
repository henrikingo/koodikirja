{
  "name": "bacon",
  "version": "0.7.2",
  "main": "dist/Bacon.js",
  "gitHead": "2bb3d5c8447799d7ae557c09a1e56495b715ccb1",
  "readme": "doc = new (require \"./readme/doc.coffee\")\n\ndoc.section \"Bacon.js\"\ndoc.logo()\ndoc.text \"\"\"\nA small functional reactive programming lib for JavaScript.\n\nTurns your event spaghetti into clean and declarative feng shui bacon, by switching\nfrom imperative to functional. It's like replacing nested for-loops with functional programming\nconcepts like [`map`](#observable-map) and `filter`. Stop working on individual events and work with event streams instead.\nCombine your data with `merge` and `combine`.\nThen switch to the heavier weapons and wield `flatMap` and `combineTemplate` like a boss.\n\nIt's the `_` of Events. Too bad the symbol `~` is not allowed in JavaScript.\n\nHere's the stuff.\n\n- [Homepage](http://baconjs.github.io/)\n- [CoffeeScript source](https://github.com/baconjs/bacon.js/blob/master/src/Bacon.coffee)\n- [Generated javascript](https://github.com/baconjs/bacon.js/blob/master/dist/)\n- [Specs](https://github.com/baconjs/bacon.js/blob/master/spec/BaconSpec.coffee)\n- [Examples](https://github.com/baconjs/bacon.js/blob/master/examples/examples.html)\n- [Wiki](https://github.com/baconjs/bacon.js/wiki/) with more docs, related projects and more\n- [Cheat Sheet](http://www.cheatography.com/proloser/cheat-sheets/bacon-js/)\n- [My Blog](http://nullzzz.blogspot.com) with some baconful and reactive postings along with a Bacon.js tutorial\n- [Bacon.js Blog](http://baconjs.blogspot.com)\n- [Bacon.js Google Group](https://groups.google.com/forum/#!forum/baconjs) for discussion and questions\n- [TodoMVC with Bacon.js and jQuery](https://github.com/raimohanska/todomvc/blob/bacon-jquery/labs/architecture-examples/baconjs/js/app.js)\n- [Stack Overflow](http://stackoverflow.com/questions/tagged/bacon.js) for well-formed questions. Use the \"bacon.js\" tag.\n\nYou can also check out my entertaining (LOL), interactive, solid-ass [slideshow](http://raimohanska.github.com/bacon.js-slides/).\n\nAnd remember to give me feedback on the bacon! Let me know if you've\nused it. Tell me how it worked for you. What's missing? What's wrong?\nPlease contribute!\n\n[![Build Status](https://travis-ci.org/baconjs/bacon.js.png?branch=master)](https://travis-ci.org/baconjs/bacon.js)\n\"\"\"\n\ndoc.toc()\n\ndoc.section \"Install\"\ndoc.text \"\"\"\nYou can download the latest [generated javascript](https://raw.github.com/baconjs/bacon.js/master/dist/Bacon.js).\n\nVersion 0.7.0 can also be found from cdnjs hosting:\n\n    http://cdnjs.cloudflare.com/ajax/libs/bacon.js/0.7.0/Bacon.js\n    http://cdnjs.cloudflare.com/ajax/libs/bacon.js/0.7.0/Bacon.min.js\n\nVisual Studio users can obtain version 0.7.0 via NuGet Packages\n    https://www.nuget.org/packages/Bacon.js/0.7.0\n\nIf you're targeting to [node.js](http://nodejs.org/), you can\n\n    npm install baconjs\n\nFor [bower](https://github.com/twitter/bower) users:\n\n    bower install bacon\n\"\"\"\n\ndoc.section \"Intro\"\ndoc.text \"\"\"\nThe idea of Functional Reactive Programming is quite well described by Conal Elliot at [Stack Overflow](http://stackoverflow.com/questions/1028250/what-is-functional-reactive-programming/1030631#1030631).\n\nBacon.js is a library for functional reactive programming. Or let's say it's a library for\nworking with [events](#event) and dynamic values (which are called [Properties](#property) in Bacon.js).\n\nAnyways, you can wrap an event source,\nsay \"mouse clicks on an element\" into an `EventStream` by saying\n\n```js\nvar cliks = $(\"h1\").asEventStream(\"click\")\n```\n\nEach EventStream represents a stream of events. It is an Observable object, meaning\nthat you can listen to events in the stream using, for instance, the [`onValue`](#stream-onvalue) method\nwith a callback. Like this:\n\n```js\ncliks.onValue(function() { alert(\"you clicked the h1 element\") })\n```\n\nBut you can do neater stuff too. The Bacon of bacon.js is in that you can transform,\nfilter and combine these streams in a multitude of ways (see API below). The methods [`map`](#observable-map),\n[`filter`](#observable-filter), for example, are similar to same functions in functional list programming\n(like [Underscore](http://documentcloud.github.com/underscore/)). So, if you say\n\n```js\nvar plus = $(\"#plus\").asEventStream(\"click\").map(1)\nvar minus = $(\"#minus\").asEventStream(\"click\").map(-1)\nvar both = plus.merge(minus)\n```\n\n.. you'll have a stream that will output the number 1 when the \"plus\" button is clicked\nand another stream outputting -1 when the \"minus\" button is clicked. The `both` stream will\nbe a merged stream containing events from both the plus and minus streams. This allows\nyou to subscribe to both streams with one handler:\n\n```js\nboth.onValue(function(val) { /* val will be 1 or -1 */ })\n```\n\nIn addition to EventStreams, bacon.js has a thing called [`Property`](#property), that is almost like an\nEventStream, but has a \"current value\". So things that change and have a current state are\nProperties, while things that consist of discrete events are EventStreams. You could think\nmouse clicks as an EventStream and mouse position as a Property. You can create Properties from\nan EventStream with [`scan`](#observable-scan) or [`toProperty`](#stream-toproperty) methods. So, let's say\n\n```js\nfunction add(x, y) { return x + y }\nvar counter = both.scan(0, add)\ncounter.onValue(function(sum) { $(\"#sum\").text(sum) })\n```\n\nThe `counter` property will contain the sum of the values in the `both` stream, so it's practically\na counter that can be increased and decreased using the plus and minus buttons. The [`scan`](#observable-scan) method\nwas used here to calculate the \"current sum\" of events in the `both` stream, by giving a \"seed value\"\n`0` and an \"accumulator function\" `add`. The scan method creates a property that starts with the given\nseed value and on each event in the source stream applies the accumulator function to the current\nproperty value and the new value from the stream.\n\nProperties can be very conventiently used for assigning values and attributes to DOM elements with JQuery.\nHere we assign the value of a property as the text of a span element whenever it changes:\n\n```js\nproperty.assign($(\"span\"), \"text\")\n```\n\nHiding and showing the same span depending on the content of the property value is equally straightforward\n\n```js\nfunction hiddenForEmptyValue(value) { return value == \"\" ? \"hidden\" : \"visible\" }\nproperty.map(hiddenForEmptyValue).assign($(\"span\"), \"css\", \"visibility\")\n```\n\nIn the example above a property value of \"hello\" would be mapped to \"visible\", which in turn would result in Bacon calling\n\n```js\n$(\"span\").css(\"visibility\", \"visible\")\n```\n\nFor an actual tutorial, please check out my [blog posts](http://nullzzz.blogspot.fi/2012/11/baconjs-tutorial-part-i-hacking-with.html)\n\"\"\"\n\ndoc.section \"API\"\n\ndoc.subsection \"Creating streams\"\n\ndoc.fn \"$.asEventStream(\\\"click\\\")\", \"\"\"\ncreates an EventStream from events on a\njQuery or Zepto.js object. You can pass optional arguments to add a\njQuery live selector and/or a function that processes the jQuery\nevent and its parameters, if given, like this:\n\n```js\n$(\"#my-div\").asEventStream(\"click\", \".more-specific-selector\")\n$(\"#my-div\").asEventStream(\"click\", \".more-specific-selector\", function(event, args) { return args[0] })\n$(\"#my-div\").asEventStream(\"click\", function(event, args) { return args[0] })\n```\n\"\"\"\n\ndoc.fn \"Bacon.fromPromise(promise [, abort])\", \"\"\"\ncreates an EventStream from a Promise object such as JQuery Ajax.\nThis stream will contain a single value or an error, followed immediately by stream end.  You can use the optional abort flag (i.e. ´fromPromise(p, true)´ to have the `abort` method of the given promise be called when all subscribers have been removed from the created stream.\nCheck out this [example](https://github.com/raimohanska/baconjs-examples/blob/master/resources/public/index.html).\n\"\"\"\n\ndoc.fn \"Bacon.fromEventTarget(target, eventName [, eventTransformer])\", \"\"\"\ncreates an EventStream from events\non a DOM EventTarget or Node.JS EventEmitter object. You can also pass an optional function that transforms the emitted\nevents' parameters.\n\n```js\nBacon.fromEventTarget(document.body, \"click\").onValue(function() { alert(\"Bacon!\") })\n```\n\"\"\"\n\ndoc.fn \"Bacon.fromCallback(f [, args...])\", \"\"\"\ncreates an Event stream from a function that\naccepts a callback. The function is supposed to call its callback just\nonce. For example:\n\n```js\nBacon.fromCallback(function(callback) {\n  setTimeout(function() {\n    callback(\"Bacon!\")\n  }, 1000)\n})\n```\n\nThis would create a stream that outputs a single value \"Bacon!\" and ends\nafter that. The use of setTimeout causes the value to be delayed by 1\nsecond.\n\nYou can also give any number of arguments to [`fromCallback`](#bacon-fromcallback), which will be\npassed to the function. These arguments can be simple variables, Bacon\nEventStreams or Properties. For example the following will output \"Bacon rules\":\n\n```js\nbacon = Bacon.constant('bacon')\nBacon.fromCallback(function(a, b, callback) {\n  callback(a + ' ' + b);\n}, bacon, 'rules').log();\n```\n\"\"\"\n\ndoc.fnOverload \"Bacon.fromCallback(object, methodName [, args...])\", \"object\", \"\"\"\na variant of fromCallback which calls the named method of a given object.\n\"\"\"\n\ndoc.fn \"Bacon.fromNodeCallback(f [, args...])\", \"\"\"\nbehaves the same way as [`Bacon.fromCallback`](#bacon-fromcallback),\nexcept that it expects the callback to be called in the Node.js convention:\n`callback(error, data)`, where error is null if everything is fine. For example:\n\n```js\nvar Bacon = require('baconjs').Bacon,\n    fs = require('fs');\nvar read = Bacon.fromNodeCallback(fs.readFile, 'input.txt');\nread.onError(function(error) { console.log(\"Reading failed: \" + error); });\nread.onValue(function(value) { console.log(\"Read contents: \" + value); });\n```\n\"\"\"\n\ndoc.fnOverload \"Bacon.fromNodeCallback(object, methodName [, args...])\", \"object\", \"\"\"\na variant of fromNodeCallback which calls the named method of a given object.\n\"\"\"\n\ndoc.fn \"Bacon.fromPoll(interval, f)\", \"\"\"polls given function with given interval.\nFunction should return Events: either [Bacon.Next](#bacon-next) or [Bacon.End](#bacon-end). Polling occurs only\nwhen there are subscribers to the stream. Polling ends permanently when\n`f` returns [Bacon.End](#bacon_end)\n\"\"\"\n\ndoc.fn \"Bacon.once(value)\", \"\"\"\ncreates an EventStream that delivers the given\nsingle value for the first subscriber. The stream will end immediately\nafter this value. You can also send send an `Bacon.Error` event instead of a\nvalue: `Bacon.once(new Bacon.Error(\"fail\"))`.\n\"\"\"\n\ndoc.fn \"Bacon.fromArray(values)\", \"\"\"\ncreates an EventStream that delivers the given\nseries of values (given as array) to the first subscriber. The stream ends after these\nvalues have been delivered. You can also send `Bacon.Error` events, or\nany combination of pure values and error events like this:\n`Bacon.fromArray([1, new Bacon.Error()])\n\"\"\"\n\ndoc.fn \"Bacon.interval(interval, value)\", \"\"\"\nrepeats the single element\nindefinitely with the given interval (in milliseconds)\n\"\"\"\n\ndoc.fn \"Bacon.sequentially(interval, values)\", \"\"\"\ncreates a stream containing given\nvalues (given as array). Delivered with given interval in milliseconds.\n\"\"\"\n\ndoc.fn \"Bacon.repeatedly(interval, values)\", \"\"\"\nrepeats given elements indefinitely\nwith given interval in milliseconds. For example, repeatedly(10, [1,2,3])\nwould lead to 1,2,3,1,2,3... to be repeated indefinitely.\n\"\"\"\n\ndoc.fn \"Bacon.never()\", \"\"\"\ncreates an EventStream that immediately ends.\n\"\"\"\n\ndoc.fn \"Bacon.later(delay, value)\", \"\"\"\ncreates a single-element stream that\nproduces given value after given delay (milliseconds).\n\"\"\"\n\ndoc.fn \"new Bacon.EventStream(subscribe)\", \"\"\"\ncreates an `EventStream` with the given subscribe function.\n\"\"\"\n\ndoc.text \"\"\"\n[`property.changes()`](#property-changes) creates a stream of changes to the `Property`. The stream *does not* include\nan event for the current value of the Property at the time this method was called.\n\"\"\"\n\ndoc.fn \"property.toEventStream()\", \"\"\"creates an EventStream based on this Property. The stream contains also an event for the current\nvalue of this Property at the time this method was called.\n\"\"\"\n\ndoc.text \"\"\"\n[`new Bacon.Bus()`](#new-bacon-bus) creates a pushable/pluggable stream (see [Bus](#bus) section below)\n\nPro tip: you can also put Errors into streams created with the\nconstructors above, by using an [`Bacon.Error`](#bacon-error) object instead of a plain\nvalue.\n\"\"\"\n\ndoc.subsection \"Bacon.fromBinder for custom streams\"\ndoc.text \"\"\"\nIf none of the factory methods above apply, you may of course roll your own EventStream by using `Bacon.fromBinder`.\n\"\"\"\n\ndoc.fn \"Bacon.fromBinder(subscribe)\", \"\"\"\nThe parameter `subscribe` is a function that accepts a `sink` which is a function that your `subcribe` funtion can \"push\" events to.\n\nFor example:\n\n```js\nvar stream = Bacon.fromBinder(function(sink) {\n  sink(\"first value\")\n  sink([new Bacon.Next(\"2nd\"), new Bacon.Next(\"3rd\")])\n  sink(new Bacon.Next(function() {\n    return \"This one will be evaluated lazily\"\n  }))\n  sink(new Bacon.Error(\"oops, an error\"))\n  sink(new Bacon.End())\n  return function() {\n     // unsub functionality here, this one's a no-op\n  }\n})\nstream.log()\n```\n\nAs shown in the example, you can push\n\n- A plain value, like `\"first value\"`\n- An `Event` object including `Bacon.Error` (wraps an error) and `Bacon.End` (indicates\nstream end).\n- An array of event objects at once\n\nSee another [example](http://jsfiddle.net/PG4c4/).\n\nThe subscribe function must return a function. Let's call that function\n`unsubscribe`. The returned function can be used by the subscriber to\nunsubscribe and it should release all resources that the subscribe function reserved.\n\nThe `sink` function may return `Bacon.more` or `Bacon.noMore`. It may also\nreturn undefined or anything else. Iff it returns `Bacon.noMore`, the subscriber\nmust be cleaned up just like in case of calling the `unsubscribe` function.\n\nThe EventStream will wrap your `subscribe` function so that it will\nonly be called when the first stream listener is added, and the `unsubscibe`\nfunction is called only after the last listener has been removed.\nThe subscribe-unsubscribe cycle may of course be repeated indefinitely,\nso prepare for multiple calls to the subscribe function.\n\nA note about the `new Bacon.Next(..)` constructor: You can use it like\n\n```js\nnew Bacon.Next(\"value\")\n```\n\nBut the canonical way would be\n```js\nnew Bacon.Next(function() { return \"value\") })\n```\n\nThe former version is safe only when you know that the actual value in\nthe stream is not a function.\n\nThe idea in using a function instead of a plain value is that the internals on Bacon.js take\nadvantage of lazy evaluation by deferring the evaluations of values\ncreated by [`map`](#observable-map), [`combine`](#combining-multiple-streams-and-properties).\n\"\"\"\n\ndoc.fn \"Bacon.noMore\", \"\"\"The opaque value `sink` function may return. See `Bacon.fromBinder`.\"\"\"\ndoc.fn \"Bacon.more\", \"\"\"The opaque value `sink` function may return. See `Bacon.fromBinder`.\"\"\"\n\ndoc.subsection \"Common methods in EventStreams and Properties\"\ndoc.text \"\"\"\nBoth EventStream and Property share the Observable interface, and hence\nshare a lot of methods. Common methods are listed below.\n\"\"\"\n\ndoc.fn \"observable.onValue(@ : Observable[A], f : A -> void) : Unsubscriber\", \"\"\"\nsubscribes a given handler function to the observable. Function will be called for each new value.\nThis is the simplest way to assign a side-effect to an observable. The difference\nto the `subscribe` method is that the actual stream values are\nreceived, instead of `Event` objects.\n`stream.onValue` and `property.onValue` behave similarly, except that the latter also\npushes the initial value of the property, in case there is one.\n\"\"\"\n\ndoc.fn \"observable.onError(@ : Observable[A], f : Error -> void) : Unsubscriber\", \"\"\"\nsubscribes a callback to error events. The function\nwill be called for each error in the stream.\n\"\"\"\n\ndoc.fn \"observable.onEnd(f)\", \"\"\"\nsubscribes a callback to stream end. The function will\nbe called when the stream ends. Just like `subscribe`, this method returns a function for unsubscribing.\n\"\"\"\n\ndoc.fn \"observable.map(@ : Observable[A], f : A -> B) : Observable[B]\", \"\"\"\nmaps values using given function, returning a new\nEventStream. Instead of a function, you can also provide a constant\nvalue. Further, you can use a property extractor string like\n\".keyCode\". So, if f is a string starting with a\ndot, the elements will be mapped to the corresponding field/function in the event\nvalue. For instance map(\".keyCode\") will pluck the keyCode field from\nthe input values. If keyCode was a function, the result stream would\ncontain the values returned by the function.\nThe [Function Construction rules](#function-construction-rules) below apply here.\n\"\"\"\n\ndoc.fn \"stream.map(property)\", \"\"\"\nmaps the stream events to the current value of\nthe given property. This is equivalent to `property.sampledBy(stream)`.\n\"\"\"\n\ndoc.fn \"observable.mapError(@ : Observable[A], f : E -> A) : Observable[A]\", \"\"\"\nmaps errors using given function. More\nspecifically, feeds the \"error\" field of the error event to the function\nand produces a `Next` event based on the return value.\nThe [Function Construction rules](#function-construction-rules) below apply here.\nYou can omit the argument to produce a `Next` event with `undefined` value.\n\"\"\"\n\ndoc.fn \"observable.errors(@ : Observable[A]) : Observable[A]\", \"\"\"\nreturns a stream containing [`Error`](#bacon-error) events only.\nSame as filtering with a function that always returns false.\n\"\"\"\n\ndoc.fn \"observable.skipErrors(@ : Observable[A]) : Observable[A]\", \"\"\"\nskips all errors.\n\"\"\"\n\ndoc.fn \"observable.mapEnd(@ : Observable[A], f : -> Observable[A]) : Observable[A]\", \"\"\"\nAdds an extra `Next` event just before End. The value is created\nby calling the given function when the source stream ends. Instead of a\nfunction, a static value can be used. You can omit the argument to\nproduce a Next event with `undefined` value.\n\"\"\"\n\ndoc.fn \"observable.filter(@ : Observable[A], f : A -> Bool) : Observable[A]\", \"\"\"\nfilters values using given predicate function.\nInstead of a function, you can use a constant value (true/false) or a\nproperty extractor string (like \".isValuable\") instead. Just like with\n[`map`](#observable-map), indeed.\n\"\"\"\n\ndoc.fnOverload \"observable.filter(property)\", \"property\", \"\"\"\nfilters values based on the value of a\nproperty. Event will be included in output iff the property holds `true`\nat the time of the event.\n\"\"\"\n\ndoc.fn \"observable.takeWhile(@ : Observable[A], f : A -> Bool) : Observable[A]\", \"\"\"\ntakes while given predicate function holds\ntrue. [Function Construction rules](#function-construction-rules) apply.\n\"\"\"\n\ndoc.fnOverload \"observable.takeWhile(property)\", \"property\", \"\"\"\ntakes values while the value of a\nproperty holds `true`.\n\"\"\"\n\ndoc.fn \"observable.take(@ : Observable[A], n : Number) : Observable[A]\", \"\"\"\n`observable.take(n)` takes at most n elements from the stream. Equals to\n`Bacon.never()` if `n <= 0`.\n\"\"\"\n\ndoc.fn \"observable.takeUntil(@ : Observable[A], stream : EventStream[B]) : Observable[A]\", \"\"\"\ntakes elements from source until a Next event\nappears in the other stream. If other stream ends without value, it is\nignored\n\"\"\"\n\ndoc.fn \"observable.skip(n)\", \"\"\"\nskips the first n elements from the stream\n\"\"\"\n\ndoc.fn \"observable.delay(delay)\", \"\"\"\ndelays the stream/property by given amount of milliseconds. Does not delay the initial value of a `Property`.\n\n```js\nvar delayed = source.delay(2)\n```\n\n```\nsource:    asdf----asdf----\ndelayed:   --asdf----asdf--\n```\n\"\"\"\n\ndoc.fn \"observable.throttle(delay)\", \"\"\"\nthrottles stream/property by given amount\nof milliseconds. Events are emitted with the minimum interval of\n`delay`. The implementation is based on `stream.bufferWithTime`.\nDoes not affect emitting the initial value of a `Property`.\n\nExample:\n\n```js\nvar throttled = source.throttle(2)\n```\n\n```\nsource:    asdf----asdf----\nthrottled: --s--f----s--f--\n```\n\"\"\"\n\ndoc.fn \"observable.debounce(delay)\", \"\"\"\nthrottles stream/property by given amount\nof milliseconds, but so that event is only emitted after the given\n\"quiet period\". Does not affect emitting the initial value of a Property.\nThe difference of `throttle` and `debounce` is the same as it is in the\nsame methods in jQuery.\n\nExample:\n\n```\nsource:             asdf----asdf----\nsource.debounce(2): -----f-------f--\n```\n\"\"\"\n\ndoc.fn \"observable.debounceImmediate(delay)\", \"\"\"\npasses the first event in the\nstream through, but after that, only passes events after a given number\nof milliseconds have passed since previous output.\n\nExample:\n\n```\nsource:                      asdf----asdf----\nsource.debounceImmediate(2): a-d-----a-d-----\n```\n\"\"\"\n\ndoc.fn \"observable.doAction(f)\", \"\"\"\nreturns a stream/property where the function f\nis executed for each value, before dispatching to subscribers. This is\nuseful for debugging, but also for stuff like calling the\n`preventDefault()` method for events. In fact, you can\nalso use a property-extractor string instead of a function, as in\n`\".preventDefault\"`.\n\"\"\"\n\ndoc.fn \"observable.not(@ : Obserable[A]) : Observable[Bool]\", \"\"\"\nreturns a stream/property that inverts boolean values\n\"\"\"\n\ndoc.fn \"observable.flatMap(@ : Observable[A], f : A -> Observable[B] | Event[B] | B) : EventStream[B]\", \"\"\"\nfor each element in the source stream, spawn a new\nstream using the function `f`. Collect events from each of the spawned\nstreams into the result `EventStream`. This is very similar to selectMany in\nRxJs. Note that instead of a function, you can provide a\nstream/property too. Also, the return value of function `f` can be either an\n`Observable` (stream/property) or a constant value. The result of\n`flatMap` is always an `EventStream`.\n\nThe [Function Construction rules](#function-construction-rules) below apply here.\n\n`stream.flatMap()` can be used conveniently with `Bacon.once()` and `Bacon.never()` for converting and filtering at the same time, including only some of the results.\n\nExample - converting strings to integers, skipping empty values:\n\n```js\nstream.flatMap(function(text) {\n    return (text != \"\") ? parseInt(text) : Bacon.never()\n})\n```\n\"\"\"\n\ndoc.fn \"observable.flatMapLatest(f)\", \"\"\"\nlike flatMap, but instead of including events from\nall spawned streams, only includes them from the latest spawned stream.\nYou can think this as switching from stream to stream.\nNote that instead of a function, you can provide a stream/property too.\n\nThe [Function Construction rules](#function-construction-rules) below apply here.\n\"\"\"\n\ndoc.fn \"observable.flatMapFirst(f)\", \"\"\"\nlike flatMap, but doesn't spawns a new\nstream only if the previously spawned stream has ended.\n\"\"\"\n\ndoc.fn \"observable.scan(seed, f) : Property[A]\", \"\"\"\nscans stream/property with given seed value and\naccumulator function, resulting to a Property. For example, you might\nuse zero as seed and a \"plus\" function as the accumulator to create\nan \"integral\" property. Instead of a function, you can also supply a\nmethod name such as \".concat\", in which case this method is called on\nthe accumulator value and the new stream value is used as argument.\n\nExample:\n\n```js\nvar plus = function (a,b) { return a + b }\nBacon.sequentially(1, [1,2,3]).scan(0, plus)\n```\n\nThis would result to following elements in the result stream:\n\n    seed value = 0\n    0 + 1 = 1\n    1 + 2 = 3\n    3 + 3 = 6\n\nWhen applied to a Property as in `r = p.scan(seed, f)`, there's a (hopefully insignificant) catch:\nThe starting value for `r` depends on whether `p` has an\ninitial value when scan is applied. If there's no initial value, this works\nidentically to EventStream.scan: the `seed` will be the initial value of\n`r`. However, if `r` already has a current/initial value `x`, the\nseed won't be output as is. Instead, the initial value of `r` will be `f(seed, x)`. This makes sense,\nbecause there can only be 1 initial value for a Property at a time.\n\"\"\"\n\ndoc.fn \"observable.fold(seed, f) : Property[A]\", \"\"\"\nis like `scan` but only emits the final\nvalue, i.e. the value just before the observable ends. Returns a\n`Property`.\n\"\"\"\n\ndoc.fn \"observable.reduce(seed,f)\", \"synonym for `fold`.\"\n\ndoc.fn \"observable.diff(start, f)\", \"\"\"\nreturns a Property that represents the result of a comparison\nbetween the previous and current value of the Observable. For the initial value of the Observable,\nthe previous value will be the given start.\n\nExample:\n\n```js\nvar distance = function (a,b) { return Math.abs(b - a) }\nBacon.sequentially(1, [1,2,3]).diff(0, distance)\n```\n\nThis would result to following elements in the result stream:\n\n    1 - 0 = 1\n    2 - 1 = 1\n    3 - 2 = 1\n\"\"\"\n\ndoc.fn \"observable.zip(other, f)\", \"\"\"\nreturn an EventStream with elements\npair-wise lined up with events from this and the other stream.\nA zipped stream will publish only when it has a value from each\nstream and will only produce values up to when any single stream ends.\n\nBe careful not to have too much \"drift\" between streams. If one stream\nproduces many more values than some other excessive buffering will\noccur inside the zipped observable.\n\nExample 1:\n\n```js\nvar x = Bacon.fromArray([1, 2])\nvar y = Bacon.fromArray([3, 4])\nx.zip(y, function(x, y) { return x + y })\n\n# produces values 4, 6\n```\n\nExample 2:\n\nYou can use zip to combine observables that are pairwise synchronized\nfrom e.g. projections or sampling by the same property, while avoiding\nthe double-processing that would happen recombining with `combine`.\n\n```js\nvar x = obs.map('.x')\nvar y = obs.map('.y')\nx.zip(y, makeComplex)\n```\n\"\"\"\n\ndoc.fn \"observable.slidingWindow(max[, min])\", \"\"\"\nreturns a Property that represents a\n\"sliding window\" into the history of the values of the Observable. The\nresult Property will have a value that is an array containing the last `n`\nvalues of the original observable, where `n` is at most the value of the\n`max` argument, and at least the value of the `min` argument. If the\n`min` argument is omitted, there's no lower limit of values.\n\nFor example, if you have a stream `s` with value a sequence 1 - 2 - 3 - 4 - 5, the\nrespective values in `s.slidingWindow(2)` would be [] - [1] - [1,2] -\n[2,3] - [3,4] - [4,5]. The values of `s.slidingWindow(2,2)`would be\n[1,2] - [2,3] - [3,4] - [4,5].\n\"\"\"\n\ndoc.fn \"observable.log()\", \"\"\"\nlogs each value of the Observable to the console.\nIt optionally takes arguments to pass to console.log() alongside each\nvalue. To assist with chaining, it returns the original Observable. Note\nthat as a side-effect, the observable will have a constant listener and\nwill not be garbage-collected. So, use this for debugging only and\nremove from production code. For example:\n\n```js\nmyStream.log(\"New event in myStream\")\n```\n\nor just\n\n```js\nmyStream.log()\n```\n\"\"\"\n\ndoc.fn \"observable.combine(property2, f)\", \"\"\"\ncombines the latest values of the two\nstreams or properties using a two-arg function. Similarly to `scan`, you can use a\nmethod name instead, so you could do `a.combine(b, \".concat\")` for two\nproperties with array value. The result is a Property.\n\"\"\"\n\ndoc.fn \"observable.withStateMachine(initState, f)\", \"\"\"\nlets you run a state machine\non an observable. Give it an initial state object and a state\ntransformation function that processes each incoming event and\nreturns and array containing the next state and an array of output\nevents. Here's an an example, where we calculate the total sum of all\nnumbers in the stream and output the value on stream end:\n\n```js\nBacon.fromArray([1,2,3])\n  .withStateMachine(0, function(sum, event) {\n    if (event.hasValue())\n      return [sum + event.value(), []]\n    else if (event.isEnd())\n      return [undefined, [new Bacon.Next(sum), event]]\n    else\n      return [sum, [event]]\n  })\n```\n\"\"\"\n\ndoc.fn \"observable.decode(mapping)\", \"\"\"\ndecodes input using the given mapping. Is a\nbit like a switch-case or the decode function in Oracle SQL. For\nexample, the following would map the value 1 into the the string \"mike\"\nand the value 2 into the value of the `who` property.\n\n```js\nproperty.decode({1 : \"mike\", 2 : who})\n```\n\nThis is actually based on `combineTemplate` so you can compose static\nand dynamic data quite freely, as in\n\n```js\nproperty.decode({1 : { type: \"mike\" }, 2 : { type: \"other\", whoThen : who }})\n```\n\nThe return value of `decode` is always a `Property`.\n\"\"\"\n\ndoc.fn \"observable.awaiting(otherObservable)\", \"\"\"\ncreates a Property that indicates whether\n`observable` is awaiting `otherObservable`, i.e. has produced a value after the latest\nvalue from `otherObservable`. This is handy for keeping track whether we are\ncurrently awaiting an AJAX response:\n\n```js\nvar showAjaxIndicator = ajaxRequest.awaiting(ajaxResponse)\n```\n\"\"\"\n\ndoc.fn \"observable.endOnError()\", \"\"\"\nends the `Observable` on first [`Error`](#bacon-error) event. The\nerror is included in the output of the returned `Observable`.\n\"\"\"\n\ndoc.fnOverload \"observable.endOnError(f)\", \"f\", \"\"\"\nends the `Observable` on first [`Error`](#bacon-error) event for which\nthe given predicate function returns true. The error is included in the\noutput of the returned `Observable`. The [Function Construction rules](#function-construction-rules) apply, so\nyou can do for example `.endOnError(\".serious\")`.\n\"\"\"\n\ndoc.fn \"observable.withHandler(f)\", \"\"\"\nlets you do more custom event handling: you\nget all events to your function and you can output any number of events\nand end the stream if you choose. For example, to send an error and end\nthe stream in case a value is below zero:\n\n```js\nif (event.hasValue() && event.value() < 0) {\n  this.push(new Bacon.Error(\"Value below zero\"));\n  return this.push(end());\n} else {\n  return this.push(event);\n}\n```\n\nNote that it's important to return the value from `this.push` so that\nthe connection to the underlying stream will be closed when no more\nevents are needed.\n\"\"\"\n\ndoc.fn \"observable.name(@ : Observable[A], newName : String) : Observable[A]\", \"\"\"\nsets the name of the observable. Overrides the default\nimplementation of `toString` and `inspect`.\nReturns itself.\n\"\"\"\n\ndoc.subsection \"EventStream\"\ndoc.fn \"Bacon.EventStream\", \"a stream of events. See methods below.\"\n\ndoc.fn \"stream.subscribe(f)\", \"\"\"\nsubscribes given handler function to\nevent stream. Function will receive Event objects (see below).\nThe subscribe() call returns a `unsubscribe` function that you can\ncall to unsubscribe. You can also unsubscribe by returning\n`Bacon.noMore` from the handler function as a reply to an Event.\n\"\"\"\n\ndoc.fn \"stream.onValue(f)\", \"\"\"\nsubscribes a given handler function to event\nstream. Function will be called for each new value in the stream. This\nis the simplest way to assign a side-effect to a stream. The difference\nto the `subscribe` method is that the actual stream values are\nreceived, instead of `Event` objects.\nThe [Function Construction rules](#function-construction-rules) below apply here.\nJust like `subscribe`, this method returns a function for unsubscribing.\n\"\"\"\n\ndoc.fn \"stream.onValues(f)\", \"\"\"\nlike [`onValue`](#stream-onvalue), but splits the value (assuming its an\narray) as function arguments to `f`.\n\"\"\"\n\ndoc.fn \"stream.skipDuplicates([isEqual])\", \"\"\"\ndrops consecutive equal elements. So,\nfrom `[1, 2, 2, 1]` you'd get `[1, 2, 1]`. Uses the `===` operator for equality\nchecking by default. If the isEqual argument is supplied, checks by calling\nisEqual(oldValue, newValue). For instance, to do a deep comparison,you can\nuse the isEqual function from [underscore.js](http://underscorejs.org/)\nlike `stream.skipDuplicates(_.isEqual)`.\n\"\"\"\n\ndoc.fn \"stream.concat(otherStream)\", \"\"\"\nconcatenates two streams into one stream so that\nit will deliver events from `stream` until it ends and then deliver\nevents from `otherStream`. This means too that events from `stream2`,\noccurring before the end of `stream` will not be included in the result\nstream.\n\"\"\"\n\ndoc.fn \"stream.merge(otherStream)\", \"\"\"\nmerges two streams into one stream that delivers events from both\n\"\"\"\n\ndoc.fn \"stream.startWith(value)\", \"\"\"\nadds a starting value to the stream, i.e. concats a\nsingle-element stream contains `value` with this stream.\n\"\"\"\n\ndoc.fn \"stream.skipWhile(f)\", \"\"\"\nskips elements while given predicate function holds true.\nThe [Function Construction rules](#function-construction-rules) below apply here.\n\"\"\"\n\ndoc.fnOverload \"stream.skipWhile(property)\", \"property\", \"\"\"\nskips elements while the value of the given Property is `true`.\n\"\"\"\n\ndoc.fn \"stream.skipUntil(stream2)\", \"\"\"\nskips elements from `stream` until a Next event\nappears in `stream2`. In other words, starts delivering values\nfrom `stream` after first event appears in `stream2`.\n\"\"\"\n\ndoc.fn \"stream.bufferWithTime(delay)\", \"\"\"\nbuffers stream events with given delay.\nThe buffer is flushed at most once in the given delay. So, if your input\ncontains [1,2,3,4,5,6,7], then you might get two events containing [1,2,3,4]\nand [5,6,7] respectively, given that the flush occurs between numbers 4 and 5.\n\"\"\"\n\ndoc.fnOverload \"stream.bufferWithTime(f)\", \"f\", \"\"\"\nworks with a given \"defer-function\" instead\nof a delay. Here's a simple example, which is equivalent to\nstream.bufferWithTime(10):\n\n```js\nstream.bufferWithTime(function(f) { setTimeout(f, 10) })\n```\n\"\"\"\n\ndoc.fn \"stream.bufferWithCount(count)\", \"\"\"\nbuffers stream events with given count.\nThe buffer is flushed when it contains the given number of elements. So, if\nyou buffer a stream of `[1, 2, 3, 4, 5]` with count `2`, you'll get output\nevents with values `[1, 2]`, `[3, 4]` and `[5]`.\n\"\"\"\n\ndoc.fn \"stream.bufferWithTimeOrCount(delay, count)\", \"\"\"\nbuffers stream events and\nflushes when either the buffer contains the given number elements or the\ngiven amount of milliseconds has passed since last buffered event.\n\"\"\"\n\ndoc.fn \"stream.toProperty(@ : EventStream[A]) : Property[A]\", \"\"\"\ncreates a Property based on the\nEventStream. Without arguments, you'll get a Property without an initial value.\nThe Property will get its first actual value from the stream, and after that it'll\nalways have a current value.\n\"\"\"\n\ndoc.fnOverload \"stream.toProperty(initialValue)\", \"initialValue\", \"\"\"\ncreates a Property based on the\nEventStream with the given initial value that will be used as the current value until\nthe first value comes from the stream.\n\"\"\"\n\ndoc.subsection \"Property\"\n\ndoc.fn \"Bacon.Property\", \"\"\"\na reactive property. Has the concept of \"current value\".\nYou can create a Property from an EventStream by using either toProperty\nor scan method. Note depending on how a Property is created, it may or may not\nhave an initial value.\n\"\"\"\n\ndoc.fn \"Bacon.constant(x)\", \"\"\"\ncreates a constant property with value x.\n\"\"\"\n\ndoc.fn \"property.subscribe(f)\", \"\"\"\nsubscribes a handler function to property. If there's\na current value, an `Initial` event will be pushed immediately. `Next`\nevent will be pushed on updates and an `Bacon.End` event in case the source\nEventStream ends. Returns a function that you call to unsubscribe.\n\"\"\"\n\ndoc.fn \"property.onValue(f)\", \"\"\"\nsimilar to `stream.onValue`, except that also\npushes the initial value of the property, in case there is one.\nSee [Function Construction rules](#function-construction-rules) below for different forms of calling this method.\nJust like `subscribe`, this method returns a function for unsubscribing.\n\"\"\"\n\ndoc.fn \"property.onValues(f)\", \"\"\"\nlike onValue, but splits the value (assuming its an\narray) as function arguments to `f`\n\"\"\"\n\ndoc.fn \"property.assign(obj, method, [param...])\", \"\"\"\ncalls the method of the given\nobject with each value of this Property. You can optionally supply\narguments which will be used as the first arguments of the method call.\nFor instance, if you want to assign your Property to the \"disabled\"\nattribute of a JQuery object, you can do this:\n\n```js\nmyProperty.assign($(\"#my-button\"), \"attr\", \"disabled\")\n```\n\nA simpler example would be to toggle the visibility of an element based\non a Property:\n\n```js\nmyProperty.assign($(\"#my-button\"), \"toggle\")\n```\n\nNote that the `assign` method is actually just a synonym for [`onValue`](#property-onvalue) and\nthe [function construction rules](#function-construction-rules) below apply to both.\n\"\"\"\n\ndoc.fn \"property.sample(interval)\", \"\"\"\ncreates an EventStream by sampling the\nproperty value at given interval (in milliseconds)\n\"\"\"\n\ndoc.fn \"property.sampledBy(stream)\", \"\"\"\ncreates an EventStream by sampling the\nproperty value at each event from the given stream. The result\nEventStream will contain the property value at each event in the source\nstream.\n\"\"\"\n\ndoc.fnOverload \"property.sampledBy(property)\", \"property\", \"\"\"\ncreates a Property by sampling the\nproperty value at each event from the given property. The result\nProperty will contain the property value at each event in the source\nproperty.\n\"\"\"\n\ndoc.fnOverload \"property.sampledBy(streamOrProperty, f)\", \"f\", \"\"\"\nsamples the property on stream\nevents. The result values will be formed using the given function\n`f(propertyValue, samplerValue)`. You can use a method name (such as\n\".concat\") instead of a function too.\n\"\"\"\n\ndoc.fn \"property.skipDuplicates([isEqual])\", \"\"\"\ndrops consecutive equal elements. So,\nfrom `[1, 2, 2, 1]` you'd get `[1, 2, 1]`. Uses the `===` operator for equality\nchecking by default. If the `isEqual` argument is supplied, checks by calling\n`isEqual(oldValue, newValue)`. The old name for this method was\n`distinctUntilChanged`.\n\"\"\"\n\ndoc.fn \"property.changes()\", \"\"\"\nreturns an `EventStream` of property value changes.\nReturns exactly the same events as the property itself, except any Initial\nevents. Note that `property.changes()` does NOT skip duplicate values, use .skipDuplicates() for that.\n\"\"\"\n\ndoc.fn \"property.and(other)\", \"\"\"\ncombines properties with the `&&` operator.\n\"\"\"\n\ndoc.fn \"property.or(other)\", \"\"\"\ncombines properties with the `||` operator.\n\"\"\"\n\ndoc.fn \"property.startWith(value)\", \"\"\"\nadds an initial \"default\" value for the\nProperty. If the Property doesn't have an initial value of it's own, the\ngiven value will be used as the initial value. If the property has an\ninitial value of its own, the given value will be ignored.\n\"\"\"\n\ndoc.subsection \"Combining multiple streams and properties\"\n\ndoc.fn \"Bacon.combineAsArray(streams)\", \"\"\"\ncombines Properties, EventStreams and\nconstant values so that the result Property will have an array of all\nproperty values as its value. The input array may contain both Properties\nand EventStreams. In the latter case, the stream is first converted into\na Property and then combined with the other properties.\n\"\"\"\n\ndoc.fnOverload \"Bacon.combineAsArray(s1, s2, ...)\", \"multiple-streams\", \"\"\"\njust like above, but with streams\nprovided as a list of arguments as opposed to a single array.\n\n```js\nproperty = Bacon.constant(1)\nstream = Bacon.once(2)\nconstant = 3\nBacon.combineAsArray(property, stream, constant)\n# produces the value [1,2,3]\n```\n\"\"\"\n\ndoc.fn \"Bacon.combineWith(f, stream1, stream2 ...)\", \"\"\"\ncombines given *n* Properties,\nEventStreams and constant values using the given n-ary function `f(v1, v2 ...)`.\nTo calculate the current sum of three numeric Properties, you can do\n\n```js\nfunction sum3(x,y,z) { return x + y + z }\nBacon.combineWith(sum3, p1, p2, p3)\n```\n\"\"\"\n\ndoc.fn \"Bacon.combineTemplate(template)\", \"\"\"\ncombines Properties, EventStreams and\nconstant values using a template\nobject. For instance, assuming you've got streams or properties named\n`password`, `username`, `firstname` and `lastname`, you can do\n\n```js\nvar password, username, firstname, lastname; // <- properties or streams\nvar loginInfo = Bacon.combineTemplate({\n    magicNumber: 3,\n    userid: username,\n    passwd: password,\n    name: { first: firstname, last: lastname }})\n```\n\n.. and your new loginInfo property will combine values from all these\nstreams using that template, whenever any of the streams/properties\nget a new value. For instance, it could yield a value such as\n\n```js\n{ magicNumber: 3,\n  userid: \"juha\",\n  passwd: \"easy\",\n  name : { first: \"juha\", last: \"paananen\" }}\n```\n\nIn addition to combining data from streams, you can include constant\nvalues in your templates.\n\nNote that all Bacon.combine* methods produce a Property instead of an EventStream.\nIf you need the result as an `EventStream` you might want to use `property.changes()`\n\n```js\nBacon.combineWith(function(v1,v2) { .. }, stream1, stream2).changes()\n```\n\"\"\"\n\ndoc.fn \"Bacon.mergeAll(streams)\", \"\"\"\nmerges given array of EventStreams.\n`Bacon.mergeAll(stream1, stream2 ...)` merges given EventStreams.\n\"\"\"\n\ndoc.fn \"Bacon.zipAsArray(streams)\", \"\"\"\nzips the array of stream in to a new\nEventStream that will have an array of values from each source stream as\nits value. Zipping means that events from each stream are combine\npairwise so that the 1st event from each stream is published first, then\nthe 2nd event from each. The results will be published as soon as there\nis a value from each source stream.\n\nBe careful not to have too much \"drift\" between streams. If one stream\nproduces many more values than some other excessive buffering will\noccur inside the zipped observable.\n\nExample:\n\n```js\nx = Bacon.fromArray([1,2,3])\ny = Bacon.fromArray([10, 20, 30])\nz = Bacon.fromArray([100, 200, 300])\nBacon.zipAsArray(x, y, z)\n\n# produces values 111, 222, 333\n```\n\"\"\"\n\ndoc.fnOverload \"Bacon.zipAsArray(stream1, stream2, ..)\", \"stream1\", \"\"\"\njust like above, but with streams\nprovided as a list of arguments as opposed to a single array.\n\"\"\"\n\ndoc.fn \"Bacon.zipWith(streams, f)\", \"\"\"\nlike `zipAsArray` but uses the given n-ary\nfunction to combine the n values from n streams, instead of returning them in an Array.\n\"\"\"\n\ndoc.fnOverload \"Bacon.zipWith(f, stream1, stream1 ...)\", \"f\", \"\"\"\njust like above, but with streams\nprovided as a list of arguments as opposed to a single array.\n\"\"\"\n\ndoc.fn \"Bacon.onValues(a, b [, c...], f)\", \"\"\"\nis a shorthand for combining multiple\nsources (streams, properties, constants) as array and assigning the\nside-effect function f for the values. The following example would log\nthe number 3.\n\n```js\nfunction f(a, b) { console.log(a + b) }\nBacon.onValues(Bacon.constant(1), Bacon.constant(2), f)\n```\n\"\"\"\n\ndoc.subsection \"Function Construction rules\"\ndoc.text \"\"\"\nMany methods in Bacon have a single function as their argument. Many of these\nactually accept a wider range of different arguments that they use for\nconstructing the function.\n\nHere are the different forms you can use, with examples. The basic form\nwould be\n\n`stream.map(f)` maps values using the function f(x)\n\nAs an extension to the basic form, you can use partial application:\n\n`stream.map(f, \"bacon\")` maps values using the function f(x, y), using\n\"bacon\" as the first argument, and stream value as the second argument.\n\n`stream.map(f, \"pow\", \"smack\")` maps values using the function f(x, y,\nz), using \"pow\" and \"smack\" as the first two arguments and stream value\nas the third argument.\n\nThen, you can create method calls like this:\n\n`stream.onValue(object, method)` calls the method having the given name,\nwith stream value as the argument.\n\n`titleText.onValue($(\"#title\"), \"text\")` which would call the \"text\" method of the jQuery object matching to the HTML element with the id \"title\"\n\n`disableButton.onValue($(\"#send\"), \"attr\", \"disabled\")` which would call\nthe attr method of the #send element, with \"disabled\" as the first\nargument. So if your property has the value `true`, it would call\n$(\"#send\").attr(\"disabled\", true)\n\nYou can call methods or return field values using a \"property extractor\"\nsyntax. With this syntax, Bacon checks the type of the field and if it's indeed a method, it calls it. Otherwise it just returns field value. For example:\n\n`stream.map(\".length\")` would return the value of the \"length\" field of\nstream values. Would make sense for a stream of arrays. So, you'd get 2\nfor `[\"cat\", \"dog\"]`\n\n`stream.map(\".stuffs.length\")` would pick the length of the \"stuffs\"\narray that is a field in the stream value. For example, you'd get 2 for\n`{ stuffs : [\"thing\", \"object\"] }`\n\n`stream.map(\".dudes.1\")` would pick the second object from the nested\n\"dudes\" array. For example, you'd get \"jack\" for `{ dudes : [\"john\",\n\"jack\"] }`.\n\n`stream.doAction(\".preventDefault\")` would call the \"preventDefault\" method of\nstream values.\n\n`stream.filter(\".attr\", \"disabled\").not()` would call `.attr(\"disabled\")` on\nstream values and filter by the return value. This would practically\ninlude only disabled jQuery elements to the result stream.\n\nIf none of the above applies, Bacon will return a constant value. For\ninstance:\n\n`mouseClicks.map({ isMouseClick: true })` would map all events to the\nobject `{ isMouseClick: true }`\n\nMethods that support function construction include\nat least [`onValue`](#observable-onvalue), `onError`, `onEnd`, [`map`](#observable-map), `filter`, `assign`, `takeWhile`, `mapError` and `doAction`.\n\"\"\"\n\ndoc.subsection \"Latest value of Property or EventStream\"\ndoc.text \"\"\"\nOne of the common first questions people ask is \"how do I get the\nlatest value of a stream or a property\". There is no getLatestValue\nmethod available and will not be either. You get the value by\nsubscribing to the stream/property and handling the values in your\ncallback. If you need the value of more than one source, use one of the\ncombine methods.\n\"\"\"\n\ndoc.subsection \"Bus\"\ndoc.text \"\"\"\n`Bus` is an `EventStream` that allows you to [`push`](#bus-push) values into the stream.\nIt also allows pluggin other streams into the Bus. The Bus practically\nmerges all plugged-in streams and the values pushed using the [`push`](#bus-push)\nmethod.\n\"\"\"\n\ndoc.fn \"new Bacon.Bus()\", \"\"\"\nreturns a new Bus.\n\"\"\"\n\ndoc.fn \"bus.push(@ : Bus[A], x : A)\", \"\"\"\npushes the given value to the stream.\n\"\"\"\n\ndoc.fn \"bus.end(@ : Bus[A])\", \"\"\"\nends the stream. Sends an End event to all subscribers.\nAfter this call, there'll be no more events to the subscribers.\nAlso, the `bus.push` and `bus.plug` methods have no effect.\n\"\"\"\n\ndoc.fn \"bus.error(@ : Bus[A], e : Error)\", \"\"\"\nsends an Error with given message to all subscribers\n\"\"\"\n\ndoc.fn \"bus.plug(@ : Bus[A], stream : EventStream[A])\", \"\"\"\nplugs the given stream to the Bus. All events from\nthe given stream will be delivered to the subscribers of the Bus.\nReturns a function that can be used to unplug the same stream.\n\nThe plug method practically allows you to merge in other streams after\nthe creation of the Bus. I've found Bus quite useful as an event broadcast\nmechanism in the\n[Worzone](https://github.com/raimohanska/worzone) game, for instance.\n\"\"\"\n\ndoc.subsection \"Event\"\n\ndoc.fn \"Bacon.Event\", \"\"\"\nhas subclasses `Bacon.Next`, `Bacon.End`, `Bacon.Error` and `Bacon.Initial`\n\"\"\"\n\ndoc.fn \"Bacon.Next\", \"\"\"\nnext value in an EventStream or a Property. Call isNext() to\ndistinguish a Next event from other events.\n\"\"\"\n\ndoc.fn \"Bacon.End\", \"\"\"\nan end-of-stream event of EventStream or Property. Call isEnd() to\ndistinguish an End from other events.\n\"\"\"\n\ndoc.fn \"Bacon.Error\", \"\"\"\nan error event. Call isError() to distinguish these events\nin your subscriber, or use `onError` to react to error events only.\n`errorEvent.error` returns the associated error object (usually string).\n\"\"\"\n\ndoc.fn \"Bacon.Initial\", \"\"\"\nthe initial (current) value of a Property. Call isInitial() to\ndistinguish from other events. Only sent immediately after subscription\nto a Property.\n\"\"\"\n\ndoc.subsubsection \"Event properties and methods\"\n\ndoc.fn \"event.value(@ : Event[A]) : A\", \"returns the value associated with a Next or Initial event\"\ndoc.fn \"event.hasValue(@ : Event[A]) : Bool\", \"returns true for events of type Initial and Next\"\ndoc.fn \"event.isNext(@ : Event[A]) : Bool\", \"true for Next events\"\ndoc.fn \"event.isInitial(@ : Event[A]) : Bool\", \"true for Initial events\"\ndoc.fn \"event.isEnd()\", \"true for End events\"\n\ndoc.subsection \"Errors\"\ndoc.text \"\"\"\n`Bacon.Error` events are always passed through all stream combinators. So, even\nif you filter all values out, the error events will pass though. If you\nuse flatMap, the result stream will contain Error events from the source\nas well as all the spawned stream.\n\nYou can take action on errors by using the `observable.onError(f)`\ncallback.\n\nSee documentation on `onError`, `mapError`, `errors`, `skipErrors` above.\n\nIn case you want to convert (some) value events into [`Error`](#bacon-error) events, you may use `flatMap` like this:\n\n```js\nstream = Bacon.fromArray([1,2,3,4]).flatMap(function(x) {\n  if (x > 2)\n    return new Bacon.Error(\"too big\")\n  else\n    return x\n})\n```\n\nAn Error does not terminate the stream. The method `observable.endOnError()`\nreturns a stream/property that ends immediately after first error.\n\nBacon.js doesn't currently generate any [`Error`](#bacon-error) events itself (except when\nconverting errors using Bacon.fromPromise). Error\nevents definitely would be generated by streams derived from IO sources\nsuch as AJAX calls.\n\"\"\"\n\ndoc.subsection \"Join Patterns\"\ndoc.text \"\"\"\nJoin patterns are a generalization of the `zip` function. While zip\nsynchronizes events from multiple streams pairwse, join patterns allow\nfor implementation of more advanced synchronization patterns. Bacon.js\nuses the `Bacon.when` function to convert a list of synchronization\npatterns into a resulting eventstream.\n\"\"\"\n\ndoc.fn \"Bacon.when\", \"\"\"\nConsider implementing a game with discrete time ticks. We want to\nhandle key-events synchronized on tick-events, with at most one key\nevent handled per tick. If there are no key events, we want to just\nprocess a tick.\n\n```js\n  Bacon.when(\n    [tick, keyEvent], function(_, k) { handleKeyEvent(k); handleTick },\n    [tick], handleTick)\n```\n\nOrder is important here. If the [tick] patterns had been written\nfirst, this would have been tried first, and preferred at each tick.\n\nJoin patterns are indeed a generalization of zip, and zip is\nequivalent to a single-rule join pattern. The following observables\nhave the same output.\n\n```js\nBacon.zipWith(a,b,c, combine)\nBacon.when([a,b,c], combine)\n```\n\"\"\"\n\ndoc.fn \"Bacon.update\", \"\"\"\nThe property version of `Bacon.when`. It requires an initial value and\nfunctions take an extra parameter representing the \"current\" value.\n\n```js\nBacon.update(\n  initial,\n  [x,y,z], function(i,x,y,z) { ... },\n  [x,y],   function(i,x,y) { ... })\n```\n\"\"\"\n\ndoc.subsubsection \"Join patterns as a \\\"chemical machine\\\"\"\ndoc.text \"\"\"\nA quick way to get some intuition for join patterns is to understand\nthem through an analogy in terms of atoms and molecules. A join\npattern can here be regarded as a recipe for a chemical reaction. Lets\nsay we have observables `oxygen`, `carbon` and `hydrogen`, where an\nevent in these spawns an 'atom' of that type into a mixture.\n\nWe can state reactions\n\n```js\nmake_water              = function(oxygen, hydrogen, hydrogen)  { /* ... consume oxygen and hydrogen ... */ }\nmake_carbon_monoxide    = function(oxygen, carbon)              { /* ... consume oxygen and carbon ... */ }\n\nBacon.when(\n  [oxygen, hydrogen, hydrogen], make_water,\n  [oxygen, carbon],             make_carbon_monoxide,\n)\n```\n\nNow, every time a new 'atom' is spawned from one of the observables,\nthis atom is added to the mixture. If at any time there are two oxygen\natoms, and a hydrogen atom, the corresponding atoms are *consumed*,\nand output is produced via `make_water`.\n\nThe same semantics apply for the second rule to create carbon\nmonoxide. The rules are tried at each point from top to bottom.\n\"\"\"\n\ndoc.subsubsection \"Join patterns and properties\"\ndoc.text \"\"\"\nProperties are not part of the synchronization pattern, but are\ninstead just sampled. The following example take three input streams\n`$price`, `$quantity` and `$total`, e.g. coming from input fields, and\ndefines mutally recursive behaviours in properties `price`, `quantity`\nand `total` such that\n\n  - updating price sets total to price * quantity\n  - updating quantity sets total to price * quantity\n  - updating total sets price to total / quantity\n\n```js\n  var $price, $total, $quantity = ...\n\n  var quantity = $quantity.toProperty(1)\n\n  var price = Bacon.when(\n    [$price], id,\n    [$total, quantity], function(x,y) { return x/y })\n   .toProperty(0)\n\n  var total = Bacon.when(\n    [$total], id,\n    [$price, quantity], function(x,y) { return x*y },\n    [price, $quantity], function(x,y) { return x*y })\n   .toProperty(0)\n\n```\n\"\"\"\n\ndoc.subsubsection \"Join patterns and Bacon.bus\"\ndoc.text \"\"\"\nThe result functions of join patterns are allowed to push values onto\na [`Bus`](#bus) that may in turn be in one of its patterns. For instance, an\nimplementation of the dining philosphers problem can be written as\nfollows.  (http://en.wikipedia.org/wiki/Dining_philosophers_problem)\n\nExample:\n\n```js\n// availability of chopsticks are implemented using Bus\nvar chopsticks = [new Bacon.Bus(), new Bacon.Bus(), new Bacon.Bus()]\n\n// hungry could be any type of observable, but we'll use bus here\nvar hungry     = [new Bacon.Bus(), new Bacon.Bus(), new Bacon.Bus()]\n\n// a philospher eats for one second, then makes the chopsticks\n// available again by pushing values onto their bus.\nvar eat = function(i) {\n  return function() {\n    setTimeout(function() {\n      console.log('done!')\n      chopsticks[i].push({})\n      chopsticks[(i+1) % 3].push({})\n    }, 1000);\n    return 'philosopher ' + i + ' eating'\n  }\n}\n\n// we use Bacon.when to make sure a hungry philosopher can eat only\n// when both his chopsticks are available.\nvar dining = Bacon.when(\n  [hungry[0], chopsticks[0], chopsticks[1]],  eat(0),\n  [hungry[1], chopsticks[1], chopsticks[2]],  eat(1),\n  [hungry[2], chopsticks[2], chopsticks[0]],  eat(2))\n\ndining.log()\n\n// make all chopsticks initially available\nchopsticks[0].push({}); chopsticks[1].push({}); chopsticks[2].push({})\n\n// make philosophers hungry in some way, in this case we just push to their bus\nfor (var i = 0; i < 3; i++) {\n  hungry[0].push({}); hungry[1].push({}); hungry[2].push({})\n}\n```\n\"\"\"\n\ndoc.subsection \"Cleaning up\"\ndoc.text \"\"\"\nAs described above, a subscriber can signal the loss of interest in new events\nin any of these two ways:\n\n1. Return `Bacon.noMore` from the handler function\n2. Call the `dispose()` function that was returned by the `subscribe()`\n   call.\n\nBased on my experience on RxJs coding, an actual side-effect subscriber\nin application-code never does this. So the business of unsubscribing is\nmostly internal business and you can ignore it unless you're working on\na custom stream implementation or a stream combinator. In that case, I\nwelcome you to contribute your stuff to bacon.js.\n\"\"\"\n\ndoc.subsection \"EventStream and Property semantics\"\ndoc.text \"\"\"\nThe state of an EventStream can be defined as (t, os) where `t` is time\nand `os` the list of current subscribers. This state should define the\nbehavior of the stream in the sense that\n\n1. When a Next event is emitted, the same event is emitted to all subscribers\n2. After an event has been emitted, it will never be emitted again, even\nif a new subscriber is registered. A new event with the same value may\nof course be emitted later.\n3. When a new subscriber is registered, it will get exactly the same\nevents as the other subscriber, after registration. This means that the\nstream cannot emit any \"initial\" events to the new subscriber, unless it\nemits them to all of its subscribers.\n4. A stream must never emit any other events after End (not even another End)\n\nThe rules are deliberately redundant, explaining the constraints from\ndifferent perspectives. The contract between an EventStream and its\nsubscriber is as follows:\n\n1. For each new value, the subscriber function is called. The new\n   value is wrapped into a `Next` event.\n2. The subscriber function returns a result which is either `Bacon.noMore` or\n`Bacon.more`. The `undefined` value is handled like `Bacon.more`.\n3. In case of `Bacon.noMore` the source must never call the subscriber again.\n4. When the stream ends, the subscriber function will be called with\n   and `Bacon.End` event. The return value of the subscribe function is\n   ignored in this case.\n\nA `Property` behaves similarly to an `EventStream` except that\n\n1. On a call to `subscribe`, it will deliver its current value\n(if any) to the provided subscriber function wrapped into an `Initial`\nevent.\n2. This means that if the Property has previously emitted the value `x`\nto its subscribers and that is the latest value emitted, it will deliver\nthis value to the new subscriber.\n3. Property may or may not have a current value to start with. Depends\non how the Property was created.\n\"\"\"\n\ndoc.subsection \"Atomic updates\"\ndoc.text \"\"\"\nFrom version 0.4.0, Bacon.js supports atomic updates to properties, with\nknown limitations.\n\nAssume you have properties A and B and property C = A + B. Assume that\nboth A and B depend on D, so that when D changes, both A and B will\nchange too.\n\nWhen D changes `d1 -> d2`, the value of A `a1 -> a2` and B changes `b1\n-> b2` simultaneously, you'd like C to update atomically so that it\nwould go directly `a1+b1 -> a2+b2`. And, in fact, it does exactly that.\nPrior to version 0.4.0, C would have an additional transitional\nstate like `a1+b1 -> a2+b1 -> a2+b2`\n\nAtomic updates are limited to Properties only, meaning that simultaneous\nevents in EventStreams will not be recognized as simultaneous and may\ncause extra transitional states to Properties. But as long as you're\njust combining Properties, you'll updates will be atomic.\n\"\"\"\n\ndoc.subsection \"For RxJs Users\"\ndoc.text \"\"\"\nBacon.js is quite similar to RxJs, so it should be pretty easy to pick up. The\nmajor difference is that in bacon, there are two distinct kinds of Observables:\nthe EventStream and the Property. The former is for discrete events while the\nlatter is for observable properties that have the concept of \"current value\".\n\nAlso, there are no \"cold observables\", which\nmeans also that all EventStreams and Properties are consistent among subscribers:\nwhen as event occurs, all subscribers will observe the same event. If you're\nexperienced with RxJs, you've probably bumped into some wtf's related to cold\nobservables and inconsistent output from streams constructed using scan and startWith.\nNone of that will happen with bacon.js.\n\nError handling is also a bit different: the Error event does not\nterminate a stream. So, a stream may contain multiple errors. To me,\nthis makes more sense than always terminating the stream on error; this\nway the application developer has more direct control over error\nhandling. You can always use [`stream.endOnError()`](#observable-endonerror) to get a stream\nthat ends on error!\n\"\"\"\n\ndoc.section \"Examples\"\ndoc.text \"\"\"\nSee [Examples](https://github.com/baconjs/bacon.js/blob/master/examples/examples.html)\n\nSee [Specs](https://github.com/baconjs/bacon.js/blob/master/spec/BaconSpec.coffee)\n\nSee Worzone [demo](http://juhajasatu.com/worzone/) and [source](http://github.com/raimohanska/worzone)\n\"\"\"\n\ndoc.section \"Install by npm\"\ndoc.text \"\"\"\nBacon uses npm to install the dependencies needed for compiling the coffeescript source and run the test. So first run:\n\n    npm install\n\"\"\"\n\ndoc.section \"Build\"\ndoc.text \"\"\"\nBuild the coffeescript source into javascript:\n\n    grunt\n\nResult javascript files will be generated in `dist` directory.\n\"\"\"\n\ndoc.section \"Test\"\ndoc.text \"\"\"\nRun unit tests:\n\n    npm test\n\nRun browser tests:\n\n    npm install\n    npm install --save-dev browserify@1.18.0\n    npm install -g testem\n    testem\n\nRun performance tests:\n\n    coffee performance/*\n\"\"\"\n\ndoc.section \"Dependencies\"\ndoc.text \"\"\"\nRuntime: jQuery or Zepto.js (optional; just for jQ/Zepto bindings)\nBuild/test: node.js, npm, coffeescript\n\"\"\"\n\ndoc.section \"Compatibility with other libs\"\ndoc.text \"\"\"\nBacon.js doesn't mess with prototypes or the global object. Only exceptions below.\n\n* It exports the Bacon object. In a browser, this is added to the window object.\n* If jQuery is defined, it adds the asEventStream method to jQuery (similarly to Zepto)\n\nSo, it should be pretty much compatible and a nice citizen.\n\nI'm not sure how it works in case some other lib adds stuff to, say, Array prototype, though. Maybe add test for this later?\n\"\"\"\n\ndoc.section \"Compatibility with browsers\"\ndoc.text \"\"\"\nTLDR: good.\n\nBacon.js is not browser dependent, because it is not a UI library.\n\nI have personally used it Bacon.js with Chrome, Firefox, Safari, IE 6+, iPhone, iPad.\n\nAutomatically tested on each commit on modern browsers and IE6+.\n\nThe full Bacon.js test suite is run on testling.ci with a wide range of browsers:\n\n[![browser support test report](http://ci.testling.com/baconjs/bacon.js.png)](http://ci.testling.com/baconjs/bacon.js)\n\nResults from those tests are quite unreliable, producing random failures, but the bottom line is that there are no outstanding compatibility issues.\n\"\"\"\n\ndoc.section \"Node.js\"\ndoc.text \"\"\"\nSure. Works. Try it out.\n\n    npm install baconjs\n\nThen type `node` and try the following\n\n```js\nBacon = require(\"baconjs\").Bacon\nBacon.sequentially(1000, [\"B\", \"A\", \"C\", \"O\", \"N\"]).log()\n```\n\"\"\"\n\ndoc.section \"AMD\"\ndoc.text \"\"\"\nYep. Currently exports Bacon through AMD and assigns to `window` for backwards\ncompatibility.\n\nIf you would like to use it with jQuery and AMD, you should monkey patch jQuery\nexplicitly so that module loading order does not matter\n\n```js\ndefine(function (require) {\n    var $ = require('jquery'),\n        Bacon = require('Bacon');\n\n    $.fn.asEventStream = Bacon.$.asEventStream;\n\n    $(document).asEventStream('click').onValue(function (e) {\n        console.log(e.clientX + ', ' + e.clientY);\n    });\n});\n```\n\"\"\"\n\ndoc.section \"Why Bacon?\"\ndoc.text \"\"\"\nWhy not RxJs or something else?\n\n- There is no \"something else\"\n- I want my bacon to be open source\n- I want good documentation for my bacon\n- I think the Observable abstraction is not good enough. It leaves too much room for variations in\nbehaviour (like hot/cold observables). I feel much more comfortable with EventStream and Property.\n- Bacon needs automatic tests. They also serve as documentation.\n- I don't like messing with the Array prototype\n- Because.\n\"\"\"\n\ndoc.section \"Contribute\"\ndoc.text \"\"\"\nUse [GitHub issues](https://github.com/baconjs/bacon.js/issues) and [Pull Requests](https://github.com/baconjs/bacon.js/pulls).\n\"\"\"\n\nmodule.exports = doc\n",
  "readmeFilename": "readme.coffee",
  "_id": "bacon@0.7.2",
  "description": "doc = new (require \"./readme/doc.coffee\")",
  "repository": {
    "type": "git",
    "url": "git://github.com/raimohanska/bacon.js"
  }
}